diff --git a/extensions/renderer/BUILD.gn b/extensions/renderer/BUILD.gn
index 5dce52a17e..2488843beb 100644
--- a/extensions/renderer/BUILD.gn
+++ b/extensions/renderer/BUILD.gn
@@ -157,6 +157,8 @@ source_set("renderer") {
     "lazy_background_page_native_handler.h",
     "logging_native_handler.cc",
     "logging_native_handler.h",
+    "main_world_portal.cc",
+    "main_world_portal.h",
     "module_system.cc",
     "module_system.h",
     "native_extension_bindings_system.cc",
diff --git a/extensions/renderer/main_world_portal.cc b/extensions/renderer/main_world_portal.cc
new file mode 100644
index 0000000000..0e5755ea59
--- /dev/null
+++ b/extensions/renderer/main_world_portal.cc
@@ -0,0 +1,402 @@
+// Copyright 2025 The Callisto Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "extensions/renderer/main_world_portal.h"
+
+#include "extensions/renderer/script_context.h"
+#include "gin/converter.h"
+#include "third_party/blink/public/web/web_local_frame.h"
+#include "v8/include/v8-context.h"
+#include "v8/include/v8-exception.h"
+#include "v8/include/v8-external.h"
+#include "v8/include/v8-function.h"
+#include "v8/include/v8-object.h"
+#include "v8/include/v8-primitive.h"
+#include "v8/include/v8-proxy.h"
+#include "v8/include/v8-template.h"
+
+namespace extensions {
+
+namespace {
+
+const char kFramePointerKey[] = "mainWorldPortal_frame";
+
+blink::WebLocalFrame* GetFrameFromHandler(v8::Isolate* isolate,
+                                          v8::Local<v8::Object> handler) {
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+  v8::Local<v8::Private> key =
+      v8::Private::ForApi(isolate, gin::StringToV8(isolate, kFramePointerKey)
+                                       .As<v8::String>());
+  v8::Local<v8::Value> value;
+  if (!handler->GetPrivate(context, key).ToLocal(&value) ||
+      !value->IsExternal()) {
+    return nullptr;
+  }
+  return static_cast<blink::WebLocalFrame*>(value.As<v8::External>()->Value());
+}
+
+}  // namespace
+
+v8::MaybeLocal<v8::Object> MainWorldPortal::GetMainWorldGlobal(
+    v8::Isolate* isolate,
+    blink::WebLocalFrame* frame) {
+  if (!frame) {
+    return v8::MaybeLocal<v8::Object>();
+  }
+
+  v8::Local<v8::Context> main_context = frame->MainWorldScriptContext();
+  if (main_context.IsEmpty()) {
+    return v8::MaybeLocal<v8::Object>();
+  }
+
+  return main_context->Global();
+}
+
+v8::MaybeLocal<v8::Context> MainWorldPortal::GetMainWorldContext(
+    v8::Isolate* isolate,
+    blink::WebLocalFrame* frame) {
+  if (!frame) {
+    return v8::MaybeLocal<v8::Context>();
+  }
+
+  v8::Local<v8::Context> main_context = frame->MainWorldScriptContext();
+  if (main_context.IsEmpty()) {
+    return v8::MaybeLocal<v8::Context>();
+  }
+
+  return main_context;
+}
+
+void MainWorldPortal::TrapGet(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+
+  if (info.Length() < 3) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Invalid trap arguments")));
+    return;
+  }
+
+  v8::Local<v8::Value> property = info[1];
+
+  v8::Local<v8::Object> handler = info.This().As<v8::Object>();
+  blink::WebLocalFrame* frame = GetFrameFromHandler(isolate, handler);
+  if (!frame) {
+    isolate->ThrowException(v8::Exception::Error(
+        gin::StringToV8(isolate, "Frame no longer available")));
+    return;
+  }
+
+  v8::Local<v8::Context> main_context;
+  if (!GetMainWorldContext(isolate, frame).ToLocal(&main_context)) {
+    isolate->ThrowException(v8::Exception::Error(
+        gin::StringToV8(isolate, "Cannot access main world context")));
+    return;
+  }
+
+  v8::Local<v8::Object> main_global;
+  if (!GetMainWorldGlobal(isolate, frame).ToLocal(&main_global)) {
+    isolate->ThrowException(v8::Exception::Error(
+        gin::StringToV8(isolate, "Cannot access main world global")));
+    return;
+  }
+
+  v8::Context::Scope context_scope(main_context);
+
+  v8::Local<v8::Value> result;
+  v8::TryCatch try_catch(isolate);
+
+  if (!main_global->Get(main_context, property).ToLocal(&result)) {
+    if (try_catch.HasCaught()) {
+      try_catch.ReThrow();
+    }
+    return;
+  }
+
+  info.GetReturnValue().Set(result);
+}
+
+void MainWorldPortal::TrapSet(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+
+  if (info.Length() < 4) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Invalid trap arguments")));
+    return;
+  }
+
+  v8::Local<v8::Value> property = info[1];
+  v8::Local<v8::Value> value = info[2];
+
+  v8::Local<v8::Object> handler = info.This().As<v8::Object>();
+  blink::WebLocalFrame* frame = GetFrameFromHandler(isolate, handler);
+  if (!frame) {
+    isolate->ThrowException(v8::Exception::Error(
+        gin::StringToV8(isolate, "Frame no longer available")));
+    return;
+  }
+
+  v8::Local<v8::Context> main_context;
+  if (!GetMainWorldContext(isolate, frame).ToLocal(&main_context)) {
+    isolate->ThrowException(v8::Exception::Error(
+        gin::StringToV8(isolate, "Cannot access main world context")));
+    return;
+  }
+
+  v8::Local<v8::Object> main_global;
+  if (!GetMainWorldGlobal(isolate, frame).ToLocal(&main_global)) {
+    isolate->ThrowException(v8::Exception::Error(
+        gin::StringToV8(isolate, "Cannot access main world global")));
+    return;
+  }
+
+  v8::Context::Scope context_scope(main_context);
+
+  v8::TryCatch try_catch(isolate);
+  v8::Maybe<bool> result = main_global->Set(main_context, property, value);
+
+  if (result.IsNothing()) {
+    if (try_catch.HasCaught()) {
+      try_catch.ReThrow();
+    }
+    return;
+  }
+
+  info.GetReturnValue().Set(result.FromJust());
+}
+
+void MainWorldPortal::TrapHas(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+
+  if (info.Length() < 2) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Invalid trap arguments")));
+    return;
+  }
+
+  v8::Local<v8::Value> property = info[1];
+
+  v8::Local<v8::Object> handler = info.This().As<v8::Object>();
+  blink::WebLocalFrame* frame = GetFrameFromHandler(isolate, handler);
+  if (!frame) {
+    info.GetReturnValue().Set(false);
+    return;
+  }
+
+  v8::Local<v8::Context> main_context;
+  if (!GetMainWorldContext(isolate, frame).ToLocal(&main_context)) {
+    info.GetReturnValue().Set(false);
+    return;
+  }
+
+  v8::Local<v8::Object> main_global;
+  if (!GetMainWorldGlobal(isolate, frame).ToLocal(&main_global)) {
+    info.GetReturnValue().Set(false);
+    return;
+  }
+
+  v8::Context::Scope context_scope(main_context);
+
+  v8::Maybe<bool> has_prop = main_global->Has(main_context, property);
+  if (has_prop.IsNothing()) {
+    info.GetReturnValue().Set(false);
+    return;
+  }
+
+  info.GetReturnValue().Set(has_prop.FromJust());
+}
+
+void MainWorldPortal::TrapOwnKeys(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+
+  v8::Local<v8::Object> handler = info.This().As<v8::Object>();
+  blink::WebLocalFrame* frame = GetFrameFromHandler(isolate, handler);
+  if (!frame) {
+    info.GetReturnValue().Set(v8::Array::New(isolate));
+    return;
+  }
+
+  v8::Local<v8::Context> main_context;
+  if (!GetMainWorldContext(isolate, frame).ToLocal(&main_context)) {
+    info.GetReturnValue().Set(v8::Array::New(isolate));
+    return;
+  }
+
+  v8::Local<v8::Object> main_global;
+  if (!GetMainWorldGlobal(isolate, frame).ToLocal(&main_global)) {
+    info.GetReturnValue().Set(v8::Array::New(isolate));
+    return;
+  }
+
+  v8::Context::Scope context_scope(main_context);
+
+  v8::Local<v8::Array> keys;
+  if (!main_global->GetOwnPropertyNames(main_context).ToLocal(&keys)) {
+    info.GetReturnValue().Set(v8::Array::New(isolate));
+    return;
+  }
+
+  info.GetReturnValue().Set(keys);
+}
+
+void MainWorldPortal::TrapGetOwnPropertyDescriptor(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+
+  if (info.Length() < 2) {
+    info.GetReturnValue().Set(v8::Undefined(isolate));
+    return;
+  }
+
+  v8::Local<v8::Value> property = info[1];
+
+  v8::Local<v8::Object> handler = info.This().As<v8::Object>();
+  blink::WebLocalFrame* frame = GetFrameFromHandler(isolate, handler);
+  if (!frame) {
+    info.GetReturnValue().Set(v8::Undefined(isolate));
+    return;
+  }
+
+  v8::Local<v8::Context> main_context;
+  if (!GetMainWorldContext(isolate, frame).ToLocal(&main_context)) {
+    info.GetReturnValue().Set(v8::Undefined(isolate));
+    return;
+  }
+
+  v8::Local<v8::Object> main_global;
+  if (!GetMainWorldGlobal(isolate, frame).ToLocal(&main_global)) {
+    info.GetReturnValue().Set(v8::Undefined(isolate));
+    return;
+  }
+
+  v8::Context::Scope context_scope(main_context);
+
+  v8::Local<v8::Value> descriptor;
+  if (!property->IsName()) {
+    info.GetReturnValue().Set(v8::Undefined(isolate));
+    return;
+  }
+
+  if (!main_global->GetOwnPropertyDescriptor(main_context, property.As<v8::Name>())
+           .ToLocal(&descriptor)) {
+    info.GetReturnValue().Set(v8::Undefined(isolate));
+    return;
+  }
+
+  info.GetReturnValue().Set(descriptor);
+}
+
+void MainWorldPortal::TrapDeleteProperty(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+
+  if (info.Length() < 2) {
+    info.GetReturnValue().Set(false);
+    return;
+  }
+
+  v8::Local<v8::Value> property = info[1];
+
+  v8::Local<v8::Object> handler = info.This().As<v8::Object>();
+  blink::WebLocalFrame* frame = GetFrameFromHandler(isolate, handler);
+  if (!frame) {
+    info.GetReturnValue().Set(false);
+    return;
+  }
+
+  v8::Local<v8::Context> main_context;
+  if (!GetMainWorldContext(isolate, frame).ToLocal(&main_context)) {
+    info.GetReturnValue().Set(false);
+    return;
+  }
+
+  v8::Local<v8::Object> main_global;
+  if (!GetMainWorldGlobal(isolate, frame).ToLocal(&main_global)) {
+    info.GetReturnValue().Set(false);
+    return;
+  }
+
+  v8::Context::Scope context_scope(main_context);
+
+  v8::Maybe<bool> result = main_global->Delete(main_context, property);
+  if (result.IsNothing()) {
+    info.GetReturnValue().Set(false);
+    return;
+  }
+
+  info.GetReturnValue().Set(result.FromJust());
+}
+
+v8::Local<v8::Object> MainWorldPortal::CreateProxyHandler(
+    v8::Isolate* isolate,
+    v8::Local<v8::Context> context) {
+  v8::EscapableHandleScope handle_scope(isolate);
+
+  v8::Local<v8::Object> handler = v8::Object::New(isolate);
+
+  auto set_trap = [&](const char* name, v8::FunctionCallback callback) {
+    v8::Local<v8::Function> func =
+        v8::Function::New(context, callback).ToLocalChecked();
+    handler->Set(context, gin::StringToV8(isolate, name), func).Check();
+  };
+
+  set_trap("get", TrapGet);
+  set_trap("set", TrapSet);
+  set_trap("has", TrapHas);
+  set_trap("ownKeys", TrapOwnKeys);
+  set_trap("getOwnPropertyDescriptor", TrapGetOwnPropertyDescriptor);
+  set_trap("deleteProperty", TrapDeleteProperty);
+
+  return handle_scope.Escape(handler);
+}
+
+bool MainWorldPortal::CreateForContext(ScriptContext* context) {
+  if (!context) {
+    return false;
+  }
+
+  blink::WebLocalFrame* frame = context->web_frame();
+  if (!frame) {
+    return false;
+  }
+
+  v8::Isolate* isolate = context->isolate();
+  v8::HandleScope handle_scope(isolate);
+  v8::Local<v8::Context> v8_context = context->v8_context();
+  v8::Context::Scope context_scope(v8_context);
+
+  v8::Local<v8::Context> main_context = frame->MainWorldScriptContext();
+  if (main_context.IsEmpty()) {
+    return false;
+  }
+
+  v8::Local<v8::Object> handler = CreateProxyHandler(isolate, v8_context);
+
+  v8::Local<v8::Private> frame_key =
+      v8::Private::ForApi(isolate, gin::StringToV8(isolate, kFramePointerKey)
+                                       .As<v8::String>());
+  handler->SetPrivate(v8_context, frame_key, v8::External::New(isolate, frame))
+      .Check();
+
+  v8::Local<v8::Object> target = v8::Object::New(isolate);
+
+  v8::Local<v8::Proxy> proxy;
+  if (!v8::Proxy::New(v8_context, target, handler).ToLocal(&proxy)) {
+    return false;
+  }
+
+  v8::Local<v8::Object> global = v8_context->Global();
+  v8::Maybe<bool> success = global->Set(
+      v8_context, gin::StringToV8(isolate, "mainWorld"), proxy);
+
+  return success.IsJust() && success.FromJust();
+}
+
+}  // namespace extensions
diff --git a/extensions/renderer/main_world_portal.h b/extensions/renderer/main_world_portal.h
new file mode 100644
index 0000000000..90579a3925
--- /dev/null
+++ b/extensions/renderer/main_world_portal.h
@@ -0,0 +1,46 @@
+// Copyright 2025 The Callisto Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_RENDERER_MAIN_WORLD_PORTAL_H_
+#define EXTENSIONS_RENDERER_MAIN_WORLD_PORTAL_H_
+
+#include "v8/include/v8-forward.h"
+
+namespace blink {
+class WebLocalFrame;
+}
+
+namespace extensions {
+
+class ScriptContext;
+
+class MainWorldPortal {
+ public:
+  static bool CreateForContext(ScriptContext* context);
+
+ private:
+  static void TrapGet(const v8::FunctionCallbackInfo<v8::Value>& info);
+  static void TrapSet(const v8::FunctionCallbackInfo<v8::Value>& info);
+  static void TrapHas(const v8::FunctionCallbackInfo<v8::Value>& info);
+  static void TrapOwnKeys(const v8::FunctionCallbackInfo<v8::Value>& info);
+  static void TrapGetOwnPropertyDescriptor(
+      const v8::FunctionCallbackInfo<v8::Value>& info);
+  static void TrapDeleteProperty(
+      const v8::FunctionCallbackInfo<v8::Value>& info);
+
+  static v8::MaybeLocal<v8::Object> GetMainWorldGlobal(
+      v8::Isolate* isolate,
+      blink::WebLocalFrame* frame);
+
+  static v8::MaybeLocal<v8::Context> GetMainWorldContext(
+      v8::Isolate* isolate,
+      blink::WebLocalFrame* frame);
+
+  static v8::Local<v8::Object> CreateProxyHandler(v8::Isolate* isolate,
+                                                   v8::Local<v8::Context> context);
+};
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_RENDERER_MAIN_WORLD_PORTAL_H_
diff --git a/extensions/renderer/native_extension_bindings_system.cc b/extensions/renderer/native_extension_bindings_system.cc
index 1508c29019..d407845881 100644
--- a/extensions/renderer/native_extension_bindings_system.cc
+++ b/extensions/renderer/native_extension_bindings_system.cc
@@ -47,6 +47,7 @@
 #include "extensions/renderer/extension_js_runner.h"
 #include "extensions/renderer/get_script_context.h"
 #include "extensions/renderer/ipc_message_sender.h"
+#include "extensions/renderer/main_world_portal.h"
 #include "extensions/renderer/module_system.h"
 #include "extensions/renderer/renderer_extension_registry.h"
 #include "extensions/renderer/renderer_frame_context_data.h"
@@ -515,6 +516,7 @@ void NativeExtensionBindingsSystem::DidCreateScriptContext(
   // since main world script contexts have a different mojom::ContextType type.
   if (context->context_type() == mojom::ContextType::kContentScript) {
     SetScriptingParams(context);
+    MainWorldPortal::CreateForContext(context);
   }
 }
 

