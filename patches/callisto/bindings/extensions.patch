--- a/extensions/renderer/BUILD.gn
+++ b/extensions/renderer/BUILD.gn
@@ -102,6 +102,8 @@ source_set("renderer") {
     "bindings/listener_tracker.h",
     "blob_native_handler.cc",
     "blob_native_handler.h",
+    "callisto_api.cc",
+    "callisto_api.h",
     "chrome_setting.cc",
     "chrome_setting.h",
     "console.cc",
@@ -157,6 +159,8 @@ source_set("renderer") {
     "lazy_background_page_native_handler.h",
     "logging_native_handler.cc",
     "logging_native_handler.h",
+    "main_world_portal.cc",
+    "main_world_portal.h",
     "module_system.cc",
     "module_system.h",
     "native_extension_bindings_system.cc",
--- /dev/null
+++ b/extensions/renderer/callisto_api.cc
@@ -0,0 +1,1233 @@
+#include "extensions/renderer/callisto_api.h"
+
+#include <cstring>
+#include <tuple>
+
+#include "extensions/renderer/script_context.h"
+#include "gin/converter.h"
+#include "third_party/blink/public/web/web_local_frame.h"
+#include "v8/include/v8-callisto.h"
+#include "v8/include/v8-context.h"
+#include "v8/include/v8-exception.h"
+#include "v8/include/v8-external.h"
+#include "v8/include/v8-function.h"
+#include "v8/include/v8-isolate.h"
+#include "v8/include/v8-object.h"
+#include "v8/include/v8-primitive.h"
+#include "v8/include/v8-profiler.h"
+#include "v8/include/v8-proxy.h"
+#include "v8/include/v8-template.h"
+
+namespace extensions {
+
+namespace {
+
+const char kCallistoFrameKey[] = "callisto_frame";
+const char kCallistoNativeAPIKey[] = "callisto_native_api";
+const char kLiveScopeFunctionKey[] = "live_scope_function";
+const char kLiveScopeIndexKey[] = "live_scope_index";
+const char kLiveScopeTypeKey[] = "live_scope_type";
+
+const char* ScopeTypeToString(v8::callisto::ScopeInfo::Type type) {
+  switch (type) {
+    case v8::callisto::ScopeInfo::kGlobal:
+      return "Global";
+    case v8::callisto::ScopeInfo::kLocal:
+      return "Local";
+    case v8::callisto::ScopeInfo::kWith:
+      return "With";
+    case v8::callisto::ScopeInfo::kClosure:
+      return "Closure";
+    case v8::callisto::ScopeInfo::kCatch:
+      return "Catch";
+    case v8::callisto::ScopeInfo::kBlock:
+      return "Block";
+    case v8::callisto::ScopeInfo::kScript:
+      return "Script";
+    case v8::callisto::ScopeInfo::kEval:
+      return "Eval";
+    case v8::callisto::ScopeInfo::kModule:
+      return "Module";
+    default:
+      return "Unknown";
+  }
+}
+
+bool GetLiveScopeData(v8::Isolate* isolate,
+                      v8::Local<v8::Object> handler,
+                      v8::Local<v8::Function>* out_function,
+                      int* out_scope_index) {
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+
+  v8::Local<v8::Private> func_key = v8::Private::ForApi(
+      isolate, gin::StringToV8(isolate, kLiveScopeFunctionKey).As<v8::String>());
+  v8::Local<v8::Private> idx_key = v8::Private::ForApi(
+      isolate, gin::StringToV8(isolate, kLiveScopeIndexKey).As<v8::String>());
+
+  v8::Local<v8::Value> func_val;
+  v8::Local<v8::Value> idx_val;
+
+  if (!handler->GetPrivate(context, func_key).ToLocal(&func_val) ||
+      !func_val->IsFunction()) {
+    return false;
+  }
+  if (!handler->GetPrivate(context, idx_key).ToLocal(&idx_val) ||
+      !idx_val->IsInt32()) {
+    return false;
+  }
+
+  *out_function = func_val.As<v8::Function>();
+  *out_scope_index = idx_val->Int32Value(context).FromJust();
+  return true;
+}
+
+void LiveScopeTrapGet(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+
+  if (info.Length() < 2) {
+    info.GetReturnValue().Set(v8::Undefined(isolate));
+    return;
+  }
+
+  v8::Local<v8::Value> property = info[1];
+
+  if (property->IsSymbol()) {
+    v8::Local<v8::Symbol> sym = property.As<v8::Symbol>();
+    v8::Local<v8::Value> desc = sym->Description(isolate);
+    if (desc->IsString()) {
+      v8::String::Utf8Value utf8(isolate, desc);
+      if (strcmp(*utf8, "Symbol.toStringTag") == 0) {
+        v8::Local<v8::Object> handler = info.This().As<v8::Object>();
+        v8::Local<v8::Private> type_key = v8::Private::ForApi(
+            isolate, gin::StringToV8(isolate, kLiveScopeTypeKey).As<v8::String>());
+        v8::Local<v8::Value> type_val;
+        if (handler->GetPrivate(context, type_key).ToLocal(&type_val) && type_val->IsString()) {
+          info.GetReturnValue().Set(type_val);
+          return;
+        }
+        info.GetReturnValue().Set(gin::StringToV8(isolate, "LiveScope"));
+        return;
+      }
+    }
+    info.GetReturnValue().Set(v8::Undefined(isolate));
+    return;
+  }
+
+  if (!property->IsString()) {
+    info.GetReturnValue().Set(v8::Undefined(isolate));
+    return;
+  }
+
+  v8::Local<v8::Object> handler = info.This().As<v8::Object>();
+  v8::Local<v8::Function> function;
+  int scope_index;
+
+  if (!GetLiveScopeData(isolate, handler, &function, &scope_index)) {
+    info.GetReturnValue().Set(v8::Undefined(isolate));
+    return;
+  }
+
+  v8::Local<v8::String> name = property.As<v8::String>();
+  v8::MaybeLocal<v8::Value> result =
+      v8::callisto::GetScopeVariable(isolate, function, scope_index, name);
+
+  if (result.IsEmpty()) {
+    info.GetReturnValue().Set(v8::Undefined(isolate));
+    return;
+  }
+
+  info.GetReturnValue().Set(result.ToLocalChecked());
+}
+
+void LiveScopeTrapSet(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+
+  if (info.Length() < 3) {
+    info.GetReturnValue().Set(false);
+    return;
+  }
+
+  v8::Local<v8::Value> property = info[1];
+  v8::Local<v8::Value> value = info[2];
+
+  if (!property->IsString()) {
+    info.GetReturnValue().Set(false);
+    return;
+  }
+
+  v8::Local<v8::Object> handler = info.This().As<v8::Object>();
+  v8::Local<v8::Function> function;
+  int scope_index;
+
+  if (!GetLiveScopeData(isolate, handler, &function, &scope_index)) {
+    info.GetReturnValue().Set(false);
+    return;
+  }
+
+  v8::Local<v8::String> name = property.As<v8::String>();
+  bool success =
+      v8::callisto::SetScopeVariable(isolate, function, scope_index, name, value);
+
+  info.GetReturnValue().Set(success);
+}
+
+void LiveScopeTrapHas(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+
+  if (info.Length() < 2) {
+    info.GetReturnValue().Set(false);
+    return;
+  }
+
+  v8::Local<v8::Value> property = info[1];
+
+  if (!property->IsString()) {
+    info.GetReturnValue().Set(false);
+    return;
+  }
+
+  v8::Local<v8::Object> handler = info.This().As<v8::Object>();
+  v8::Local<v8::Function> function;
+  int scope_index;
+
+  if (!GetLiveScopeData(isolate, handler, &function, &scope_index)) {
+    info.GetReturnValue().Set(false);
+    return;
+  }
+
+  v8::Local<v8::String> name = property.As<v8::String>();
+  bool has = v8::callisto::HasScopeVariable(isolate, function, scope_index, name);
+
+  info.GetReturnValue().Set(has);
+}
+
+void LiveScopeTrapOwnKeys(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+
+  v8::Local<v8::Object> handler = info.This().As<v8::Object>();
+  v8::Local<v8::Function> function;
+  int scope_index;
+
+  if (!GetLiveScopeData(isolate, handler, &function, &scope_index)) {
+    info.GetReturnValue().Set(v8::Array::New(isolate));
+    return;
+  }
+
+  v8::MaybeLocal<v8::Array> result =
+      v8::callisto::GetScopeVariableNames(isolate, function, scope_index);
+
+  if (result.IsEmpty()) {
+    info.GetReturnValue().Set(v8::Array::New(isolate));
+    return;
+  }
+
+  info.GetReturnValue().Set(result.ToLocalChecked());
+}
+
+void LiveScopeTrapGetOwnPropertyDescriptor(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+
+  if (info.Length() < 2) {
+    info.GetReturnValue().Set(v8::Undefined(isolate));
+    return;
+  }
+
+  v8::Local<v8::Value> property = info[1];
+
+  if (!property->IsString()) {
+    info.GetReturnValue().Set(v8::Undefined(isolate));
+    return;
+  }
+
+  v8::Local<v8::Object> handler = info.This().As<v8::Object>();
+  v8::Local<v8::Function> function;
+  int scope_index;
+
+  if (!GetLiveScopeData(isolate, handler, &function, &scope_index)) {
+    info.GetReturnValue().Set(v8::Undefined(isolate));
+    return;
+  }
+
+  v8::Local<v8::String> name = property.As<v8::String>();
+
+  if (!v8::callisto::HasScopeVariable(isolate, function, scope_index, name)) {
+    info.GetReturnValue().Set(v8::Undefined(isolate));
+    return;
+  }
+
+  v8::MaybeLocal<v8::Value> value_result =
+      v8::callisto::GetScopeVariable(isolate, function, scope_index, name);
+
+  v8::Local<v8::Object> descriptor = v8::Object::New(isolate);
+  if (!value_result.IsEmpty()) {
+    descriptor->Set(context, gin::StringToV8(isolate, "value"),
+                    value_result.ToLocalChecked()).Check();
+  } else {
+    descriptor->Set(context, gin::StringToV8(isolate, "value"),
+                    v8::Undefined(isolate)).Check();
+  }
+  descriptor->Set(context, gin::StringToV8(isolate, "writable"),
+                  v8::Boolean::New(isolate, true)).Check();
+  descriptor->Set(context, gin::StringToV8(isolate, "enumerable"),
+                  v8::Boolean::New(isolate, true)).Check();
+  descriptor->Set(context, gin::StringToV8(isolate, "configurable"),
+                  v8::Boolean::New(isolate, true)).Check();
+
+  info.GetReturnValue().Set(descriptor);
+}
+
+v8::Local<v8::Proxy> CreateLiveScopeProxy(
+    v8::Isolate* isolate,
+    v8::Local<v8::Context> context,
+    v8::Local<v8::Function> function,
+    int scope_index,
+    v8::callisto::ScopeInfo::Type scope_type,
+    v8::Local<v8::Object> scope_snapshot) {
+  v8::Local<v8::Object> handler = v8::Object::New(isolate);
+
+  auto set_trap = [&](const char* name, v8::FunctionCallback callback) {
+    v8::Local<v8::Function> func =
+        v8::Function::New(context, callback).ToLocalChecked();
+    handler->Set(context, gin::StringToV8(isolate, name), func).Check();
+  };
+
+  set_trap("get", LiveScopeTrapGet);
+  set_trap("set", LiveScopeTrapSet);
+  set_trap("has", LiveScopeTrapHas);
+  set_trap("ownKeys", LiveScopeTrapOwnKeys);
+  set_trap("getOwnPropertyDescriptor", LiveScopeTrapGetOwnPropertyDescriptor);
+
+  v8::Local<v8::Private> func_key = v8::Private::ForApi(
+      isolate, gin::StringToV8(isolate, kLiveScopeFunctionKey).As<v8::String>());
+  v8::Local<v8::Private> idx_key = v8::Private::ForApi(
+      isolate, gin::StringToV8(isolate, kLiveScopeIndexKey).As<v8::String>());
+  v8::Local<v8::Private> type_key = v8::Private::ForApi(
+      isolate, gin::StringToV8(isolate, kLiveScopeTypeKey).As<v8::String>());
+
+  handler->SetPrivate(context, func_key, function).Check();
+  handler->SetPrivate(context, idx_key, v8::Integer::New(isolate, scope_index)).Check();
+
+  std::string type_name = "LiveScope<";
+  type_name += ScopeTypeToString(scope_type);
+  type_name += ">";
+  handler->SetPrivate(context, type_key,
+                      gin::StringToV8(isolate, type_name)).Check();
+
+  return v8::Proxy::New(context, scope_snapshot, handler).ToLocalChecked();
+}
+
+blink::WebLocalFrame* GetFrameFromPrivate(v8::Isolate* isolate,
+                                           v8::Local<v8::Context> context) {
+  v8::Local<v8::Object> global = context->Global();
+  v8::Local<v8::Private> key = v8::Private::ForApi(
+      isolate, gin::StringToV8(isolate, kCallistoFrameKey).As<v8::String>());
+  v8::Local<v8::Value> value;
+  if (!global->GetPrivate(context, key).ToLocal(&value) || !value->IsExternal()) {
+    return nullptr;
+  }
+  return static_cast<blink::WebLocalFrame*>(value.As<v8::External>()->Value());
+}
+
+v8::Local<v8::Context> GetMainWorldContext(v8::Isolate* isolate,
+                                            v8::Local<v8::Context> context) {
+  blink::WebLocalFrame* frame = GetFrameFromPrivate(isolate, context);
+  if (!frame) {
+    return v8::Local<v8::Context>();
+  }
+  return frame->MainWorldScriptContext();
+}
+
+v8::Local<v8::Object> GetNativeAPI(v8::Isolate* isolate,
+                                    v8::Local<v8::Context> main_context) {
+  v8::Local<v8::Private> key = v8::Private::ForApi(
+      isolate, gin::StringToV8(isolate, kCallistoNativeAPIKey).As<v8::String>());
+  v8::Local<v8::Value> value;
+  if (!main_context->Global()->GetPrivate(main_context, key).ToLocal(&value) ||
+      !value->IsObject()) {
+    return v8::Local<v8::Object>();
+  }
+  return value.As<v8::Object>();
+}
+
+}  // namespace
+
+blink::WebLocalFrame* CallistoAPI::GetFrameFromContext(
+    v8::Isolate* isolate, v8::Local<v8::Context> context) {
+  return GetFrameFromPrivate(isolate, context);
+}
+
+void CallistoAPI::QueryObjects(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+
+  if (info.Length() < 1) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.queryObjects requires 1 argument")));
+    return;
+  }
+
+  if (!info[0]->IsObject() && !info[0]->IsFunction()) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.queryObjects: argument must be a constructor or prototype object")));
+    return;
+  }
+
+  v8::Local<v8::Context> main_context = GetMainWorldContext(isolate, context);
+  if (main_context.IsEmpty()) {
+    isolate->ThrowException(v8::Exception::Error(
+        gin::StringToV8(isolate, "Callisto.queryObjects: main world context not available")));
+    return;
+  }
+
+  v8::Local<v8::Value> prototype_arg = info[0];
+  v8::Local<v8::Object> prototype;
+
+  if (prototype_arg->IsFunction()) {
+    v8::Local<v8::Function> func = prototype_arg.As<v8::Function>();
+    v8::Local<v8::Value> proto_prop;
+    if (!func->Get(context, gin::StringToV8(isolate, "prototype")).ToLocal(&proto_prop)) {
+      isolate->ThrowException(v8::Exception::TypeError(
+          gin::StringToV8(isolate, "Callisto.queryObjects: failed to get prototype property")));
+      return;
+    }
+    if (!proto_prop->IsObject()) {
+      isolate->ThrowException(v8::Exception::TypeError(
+          gin::StringToV8(isolate, "Callisto.queryObjects: constructor prototype is not an object")));
+      return;
+    }
+    prototype = proto_prop.As<v8::Object>();
+  } else {
+    prototype = prototype_arg.As<v8::Object>();
+  }
+
+  bool skip_gc = false;
+  if (info.Length() >= 2 && info[1]->IsBoolean()) {
+    skip_gc = info[1]->BooleanValue(isolate);
+  }
+
+  v8::Context::Scope main_context_scope(main_context);
+
+  std::vector<v8::Global<v8::Object>> results;
+  v8::callisto::QueryObjects(main_context, prototype, &results, skip_gc);
+
+  v8::Local<v8::Array> result_array = v8::Array::New(isolate, results.size());
+  for (size_t i = 0; i < results.size(); ++i) {
+    result_array->Set(main_context, i, results[i].Get(isolate)).Check();
+  }
+
+  info.GetReturnValue().Set(result_array);
+}
+
+void CallistoAPI::DumpScopes(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+
+  if (info.Length() < 1) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.dumpScopes requires 1 argument")));
+    return;
+  }
+
+  if (!info[0]->IsFunction()) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.dumpScopes: argument is not a function")));
+    return;
+  }
+
+  v8::Local<v8::Function> func = info[0].As<v8::Function>();
+
+  std::vector<v8::callisto::ScopeInfo> scopes;
+  if (!v8::callisto::GetFunctionScopes(isolate, func, &scopes)) {
+    isolate->ThrowException(v8::Exception::Error(
+        gin::StringToV8(isolate, "Callisto.dumpScopes: failed to get function scopes")));
+    return;
+  }
+
+  v8::Local<v8::Object> result = v8::Object::New(isolate);
+
+  int scope_index = 0;
+  for (const auto& scope : scopes) {
+    const char* type_name = ScopeTypeToString(scope.type);
+    v8::Local<v8::String> type_key = gin::StringToV8(isolate, type_name).As<v8::String>();
+
+    v8::Local<v8::Proxy> live_scope =
+        CreateLiveScopeProxy(isolate, context, func, scope_index, scope.type, scope.object);
+
+    v8::Local<v8::Value> existing;
+    if (result->Get(context, type_key).ToLocal(&existing) && existing->IsArray()) {
+      v8::Local<v8::Array> arr = existing.As<v8::Array>();
+      arr->Set(context, arr->Length(), live_scope).Check();
+    } else {
+      v8::Local<v8::Array> arr = v8::Array::New(isolate, 1);
+      arr->Set(context, 0, live_scope).Check();
+      result->Set(context, type_key, arr).Check();
+    }
+
+    scope_index++;
+  }
+
+  info.GetReturnValue().Set(result);
+}
+
+static const char* FunctionStatusToString(v8::callisto::FunctionStatus status) {
+  switch (status) {
+    case v8::callisto::FunctionStatus::kOk:
+      return nullptr;
+    case v8::callisto::FunctionStatus::kNotFunction:
+      return "argument is not a function";
+    case v8::callisto::FunctionStatus::kBuiltinFunction:
+      return "only user-defined JavaScript functions are supported, builtin functions are not allowed";
+    case v8::callisto::FunctionStatus::kNativeFunction:
+      return "only user-defined JavaScript functions are supported, native functions are not allowed";
+    case v8::callisto::FunctionStatus::kApiFunction:
+      return "only user-defined JavaScript functions are supported, API functions are not allowed";
+    case v8::callisto::FunctionStatus::kWasmFunction:
+      return "only user-defined JavaScript functions are supported, WebAssembly functions are not allowed";
+    case v8::callisto::FunctionStatus::kNotCompiled:
+      return "function could not be compiled";
+    case v8::callisto::FunctionStatus::kNoBytecode:
+      return "function has no bytecode";
+    case v8::callisto::FunctionStatus::kLengthMismatch:
+      return "target and replacement functions must have the same number of parameters";
+    case v8::callisto::FunctionStatus::kGeneratorMismatch:
+      return "cannot hook generator function with non-generator or vice versa";
+    case v8::callisto::FunctionStatus::kAsyncMismatch:
+      return "cannot hook async function with non-async or vice versa";
+    case v8::callisto::FunctionStatus::kDerivedConstructorMismatch:
+      return "cannot hook derived constructor with base constructor or vice versa";
+  }
+  return "unknown error";
+}
+
+void CallistoAPI::HookFunction(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+
+  if (info.Length() < 2) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.functions.hook requires 2 arguments")));
+    return;
+  }
+
+  if (!info[0]->IsFunction()) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.functions.hook: first argument is not a function")));
+    return;
+  }
+
+  if (!info[1]->IsFunction()) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.functions.hook: second argument is not a function")));
+    return;
+  }
+
+  v8::Local<v8::Function> target = info[0].As<v8::Function>();
+  v8::Local<v8::Function> replacement = info[1].As<v8::Function>();
+
+  if (v8::callisto::IsFunctionHooked(context, target)) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.functions.hook: function is already hooked")));
+    return;
+  }
+
+  v8::callisto::FunctionStatus status =
+      v8::callisto::ValidateFunctionPair(context, target, replacement);
+
+  if (status != v8::callisto::FunctionStatus::kOk) {
+    std::string error = "Callisto.functions.hook: ";
+    error += FunctionStatusToString(status);
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, error)));
+    return;
+  }
+
+  v8::MaybeLocal<v8::Function> maybe_clone =
+      v8::callisto::CloneFunction(context, target);
+
+  if (maybe_clone.IsEmpty()) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.functions.hook: failed to clone function")));
+    return;
+  }
+
+  if (!v8::callisto::HookFunction(context, target, replacement)) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.functions.hook: hook operation failed")));
+    return;
+  }
+
+  info.GetReturnValue().Set(maybe_clone.ToLocalChecked());
+}
+
+void CallistoAPI::RestoreFunction(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+
+  if (info.Length() < 1) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.functions.restore requires 1 argument")));
+    return;
+  }
+
+  if (!info[0]->IsFunction()) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.functions.restore: argument is not a function")));
+    return;
+  }
+
+  v8::Local<v8::Function> target = info[0].As<v8::Function>();
+  bool restored = v8::callisto::RestoreFunction(context, target);
+  info.GetReturnValue().Set(restored);
+}
+
+void CallistoAPI::IsFunctionHooked(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+
+  if (info.Length() < 1) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.functions.isHooked requires 1 argument")));
+    return;
+  }
+
+  if (!info[0]->IsFunction()) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.functions.isHooked: argument is not a function")));
+    return;
+  }
+
+  v8::Local<v8::Function> target = info[0].As<v8::Function>();
+  bool hooked = v8::callisto::IsFunctionHooked(context, target);
+  info.GetReturnValue().Set(hooked);
+}
+
+void CallistoAPI::CloneFunction(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+
+  if (info.Length() < 1) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.functions.clone requires 1 argument")));
+    return;
+  }
+
+  if (!info[0]->IsFunction()) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.functions.clone: argument is not a function")));
+    return;
+  }
+
+  v8::Local<v8::Function> target = info[0].As<v8::Function>();
+
+  if (v8::callisto::IsFunctionHooked(context, target)) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.functions.clone: cannot clone a hooked function")));
+    return;
+  }
+
+  v8::callisto::FunctionStatus status =
+      v8::callisto::ValidateFunction(context, target);
+
+  if (status != v8::callisto::FunctionStatus::kOk) {
+    std::string error = "Callisto.functions.clone: ";
+    error += FunctionStatusToString(status);
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, error)));
+    return;
+  }
+
+  v8::MaybeLocal<v8::Function> maybe_clone =
+      v8::callisto::CloneFunction(context, target);
+
+  if (maybe_clone.IsEmpty()) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.functions.clone: clone operation failed")));
+    return;
+  }
+
+  info.GetReturnValue().Set(maybe_clone.ToLocalChecked());
+}
+
+void CallistoAPI::Dump(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+
+  if (info.Length() < 1) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.functions.dump requires 1 argument")));
+    return;
+  }
+
+  if (!info[0]->IsFunction()) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.functions.dump: argument is not a function")));
+    return;
+  }
+
+  v8::Local<v8::Function> target = info[0].As<v8::Function>();
+
+  v8::callisto::FunctionStatus status =
+      v8::callisto::ValidateFunction(context, target);
+
+  if (status != v8::callisto::FunctionStatus::kOk) {
+    std::string error = "Callisto.functions.dump: ";
+    error += FunctionStatusToString(status);
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, error)));
+    return;
+  }
+
+  v8::MaybeLocal<v8::Object> maybe_data =
+      v8::callisto::DumpFunction(context, target);
+
+  if (maybe_data.IsEmpty()) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.functions.dump: failed to dump function")));
+    return;
+  }
+
+  info.GetReturnValue().Set(maybe_data.ToLocalChecked());
+}
+
+void CallistoAPI::Build(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+
+  if (info.Length() < 1) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.functions.build requires at least 1 argument")));
+    return;
+  }
+
+  if (!info[0]->IsObject()) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.functions.build: first argument is not an object")));
+    return;
+  }
+
+  v8::Local<v8::Object> data = info[0].As<v8::Object>();
+
+  v8::Local<v8::Function> template_func;
+  if (info.Length() >= 2 && info[1]->IsFunction()) {
+    template_func = info[1].As<v8::Function>();
+
+    v8::callisto::FunctionStatus status =
+        v8::callisto::ValidateFunction(context, template_func);
+
+    if (status != v8::callisto::FunctionStatus::kOk) {
+      std::string error = "Callisto.functions.build: template function - ";
+      error += FunctionStatusToString(status);
+      isolate->ThrowException(v8::Exception::TypeError(
+          gin::StringToV8(isolate, error)));
+      return;
+    }
+  }
+
+  v8::MaybeLocal<v8::Function> maybe_func =
+      v8::callisto::BuildFunction(context, data, template_func);
+
+  if (maybe_func.IsEmpty()) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.functions.build: failed to build function")));
+    return;
+  }
+
+  info.GetReturnValue().Set(maybe_func.ToLocalChecked());
+}
+
+void CallistoAPI::WrapNative(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+
+  if (info.Length() < 1) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.functions.wrapNative requires 1 argument")));
+    return;
+  }
+
+  if (!info[0]->IsFunction()) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.functions.wrapNative: argument is not a function")));
+    return;
+  }
+
+  v8::Local<v8::Function> target = info[0].As<v8::Function>();
+
+  v8::Local<v8::String> name;
+  if (info.Length() >= 2 && info[1]->IsString()) {
+    name = info[1].As<v8::String>();
+  }
+
+  v8::Local<v8::Context> main_context = GetMainWorldContext(isolate, context);
+  if (main_context.IsEmpty()) {
+    isolate->ThrowException(v8::Exception::Error(
+        gin::StringToV8(isolate, "Callisto.functions.wrapNative: main world context not available")));
+    return;
+  }
+
+  v8::MaybeLocal<v8::Function> maybe_wrapper =
+      v8::callisto::WrapNative(main_context, target, name);
+
+  if (maybe_wrapper.IsEmpty()) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.functions.wrapNative: failed to wrap function")));
+    return;
+  }
+
+  info.GetReturnValue().Set(maybe_wrapper.ToLocalChecked());
+}
+
+void CallistoAPI::PatchProxy(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+
+  if (info.Length() < 2) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.proxies.patch requires 2 arguments")));
+    return;
+  }
+
+  if (!info[0]->IsProxy()) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.proxies.patch: first argument is not a Proxy")));
+    return;
+  }
+
+  if (!info[1]->IsObject()) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.proxies.patch: second argument is not an object")));
+    return;
+  }
+
+  v8::Local<v8::Proxy> proxy = info[0].As<v8::Proxy>();
+  v8::Local<v8::Object> new_handler = info[1].As<v8::Object>();
+
+  if (proxy->IsRevoked()) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.proxies.patch: cannot patch revoked Proxy")));
+    return;
+  }
+
+  bool success = v8::callisto::SetProxyHandler(context, proxy, new_handler);
+  info.GetReturnValue().Set(success);
+}
+
+void CallistoAPI::UnwrapProxy(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+
+  if (info.Length() < 1) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.proxies.unwrap requires 1 argument")));
+    return;
+  }
+
+  if (!info[0]->IsProxy()) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.proxies.unwrap: argument is not a Proxy")));
+    return;
+  }
+
+  v8::Local<v8::Proxy> proxy = info[0].As<v8::Proxy>();
+
+  if (proxy->IsRevoked()) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.proxies.unwrap: cannot unwrap revoked Proxy")));
+    return;
+  }
+
+  v8::Local<v8::Value> target;
+  v8::Local<v8::Value> handler;
+  v8::callisto::GetProxyInternals(proxy, &target, &handler);
+
+  v8::Local<v8::Object> result = v8::Object::New(isolate);
+  result->Set(context, gin::StringToV8(isolate, "target"), target).Check();
+  result->Set(context, gin::StringToV8(isolate, "handler"), handler).Check();
+
+  info.GetReturnValue().Set(result);
+}
+
+void CallistoAPI::IsProxy(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+
+  if (info.Length() < 1) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.proxies.isProxy requires 1 argument")));
+    return;
+  }
+
+  info.GetReturnValue().Set(info[0]->IsProxy());
+}
+
+void CallistoAPI::UnfreezeObject(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+
+  if (info.Length() < 1) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.objects.unfreeze requires 1 argument")));
+    return;
+  }
+
+  if (!info[0]->IsObject()) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.objects.unfreeze: argument is not an object")));
+    return;
+  }
+
+  v8::Local<v8::Object> target = info[0].As<v8::Object>();
+  bool success = v8::callisto::UnfreezeObject(context, target);
+  info.GetReturnValue().Set(success);
+}
+
+void CallistoAPI::UnsealObject(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+
+  if (info.Length() < 1) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.objects.unseal requires 1 argument")));
+    return;
+  }
+
+  if (!info[0]->IsObject()) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.objects.unseal: argument is not an object")));
+    return;
+  }
+
+  v8::Local<v8::Object> target = info[0].As<v8::Object>();
+  bool success = v8::callisto::UnsealObject(context, target);
+  info.GetReturnValue().Set(success);
+}
+
+void CallistoAPI::MakeExtensible(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+
+  if (info.Length() < 1) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.objects.makeExtensible requires 1 argument")));
+    return;
+  }
+
+  if (!info[0]->IsObject()) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.objects.makeExtensible: argument is not an object")));
+    return;
+  }
+
+  v8::Local<v8::Object> target = info[0].As<v8::Object>();
+  bool success = v8::callisto::MakeExtensible(context, target);
+  info.GetReturnValue().Set(success);
+}
+
+void CallistoAPI::SafeApply(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+
+  if (info.Length() < 1) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.safeApply requires 1 argument")));
+    return;
+  }
+
+  if (!info[0]->IsFunction()) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.safeApply: argument is not a function")));
+    return;
+  }
+
+  v8::Local<v8::Function> target = info[0].As<v8::Function>();
+
+  v8::Local<v8::Value> receiver = v8::Undefined(isolate);
+  if (info.Length() >= 2) {
+    receiver = info[1];
+    if (receiver->IsNull() || receiver->IsUndefined()) {
+      receiver = v8::Undefined(isolate);
+    }
+  }
+
+  std::vector<v8::Local<v8::Value>> args;
+  if (info.Length() >= 3 && info[2]->IsArray()) {
+    v8::Local<v8::Array> args_array = info[2].As<v8::Array>();
+    uint32_t len = args_array->Length();
+    args.reserve(len);
+    for (uint32_t i = 0; i < len; ++i) {
+      v8::Local<v8::Value> arg;
+      if (args_array->Get(context, i).ToLocal(&arg)) {
+        args.push_back(arg);
+      } else {
+        args.push_back(v8::Undefined(isolate));
+      }
+    }
+  } else if (info.Length() >= 3 && !info[2]->IsNullOrUndefined()) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.safeApply: third argument is not an array")));
+    return;
+  }
+
+  v8::MaybeLocal<v8::Value> result = v8::callisto::SafeApply(
+      context, target, receiver,
+      static_cast<int>(args.size()),
+      args.empty() ? nullptr : args.data());
+
+  if (!result.IsEmpty()) {
+    info.GetReturnValue().Set(result.ToLocalChecked());
+  }
+}
+
+void CallistoAPI::OverwriteProperty(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+
+  if (info.Length() < 3) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.objects.overwriteProperty requires 3 arguments")));
+    return;
+  }
+
+  if (!info[0]->IsObject()) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.objects.overwriteProperty: first argument is not an object")));
+    return;
+  }
+
+  v8::Local<v8::Object> target = info[0].As<v8::Object>();
+
+  v8::Local<v8::Name> key;
+  if (info[1]->IsString()) {
+    key = info[1].As<v8::String>();
+  } else if (info[1]->IsSymbol()) {
+    key = info[1].As<v8::Symbol>();
+  } else {
+    v8::MaybeLocal<v8::String> maybe_str = info[1]->ToString(context);
+    if (!maybe_str.ToLocal(&key)) {
+      isolate->ThrowException(v8::Exception::TypeError(
+          gin::StringToV8(isolate, "Callisto.objects.overwriteProperty: second argument must be a string or symbol")));
+      return;
+    }
+  }
+
+  if (!info[2]->IsObject()) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Callisto.objects.overwriteProperty: third argument must be a descriptor object")));
+    return;
+  }
+
+  v8::Local<v8::Object> descriptor = info[2].As<v8::Object>();
+
+  v8::Local<v8::Value> value_val;
+  v8::Local<v8::Value> writable_val;
+  v8::Local<v8::Value> enumerable_val;
+  v8::Local<v8::Value> configurable_val;
+
+  bool has_value = descriptor->Get(context, gin::StringToV8(isolate, "value")).ToLocal(&value_val) && !value_val->IsUndefined();
+  bool has_writable = descriptor->Get(context, gin::StringToV8(isolate, "writable")).ToLocal(&writable_val) && !writable_val->IsUndefined();
+  bool has_enumerable = descriptor->Get(context, gin::StringToV8(isolate, "enumerable")).ToLocal(&enumerable_val) && !enumerable_val->IsUndefined();
+  bool has_configurable = descriptor->Get(context, gin::StringToV8(isolate, "configurable")).ToLocal(&configurable_val) && !configurable_val->IsUndefined();
+
+  v8::PropertyAttribute current_attrs = v8::None;
+  v8::Local<v8::Value> current_value;
+  bool property_exists = false;
+
+  v8::Maybe<v8::PropertyAttribute> maybe_attrs = target->GetPropertyAttributes(context, key);
+  if (maybe_attrs.IsJust() && static_cast<int>(maybe_attrs.FromJust()) != static_cast<int>(v8::PropertyAttribute::None) - 1) {
+    v8::PropertyAttribute attr = maybe_attrs.FromJust();
+    if (static_cast<int>(attr) >= 0) {
+      property_exists = true;
+      current_attrs = attr;
+      std::ignore = target->Get(context, key).ToLocal(&current_value);
+    }
+  }
+
+  v8::Local<v8::Value> final_value;
+  if (has_value) {
+    final_value = value_val;
+  } else if (property_exists && !current_value.IsEmpty()) {
+    final_value = current_value;
+  } else {
+    final_value = v8::Undefined(isolate);
+  }
+
+  int attrs = 0;
+
+  if (has_writable) {
+    if (!writable_val->BooleanValue(isolate)) {
+      attrs |= v8::ReadOnly;
+    }
+  } else if (property_exists && (current_attrs & v8::ReadOnly)) {
+    attrs |= v8::ReadOnly;
+  }
+
+  if (has_enumerable) {
+    if (!enumerable_val->BooleanValue(isolate)) {
+      attrs |= v8::DontEnum;
+    }
+  } else if (property_exists && (current_attrs & v8::DontEnum)) {
+    attrs |= v8::DontEnum;
+  }
+
+  if (has_configurable) {
+    if (!configurable_val->BooleanValue(isolate)) {
+      attrs |= v8::DontDelete;
+    }
+  } else if (property_exists && (current_attrs & v8::DontDelete)) {
+    attrs |= v8::DontDelete;
+  }
+
+  bool success = v8::callisto::OverwriteProperty(
+      context, target, key, final_value,
+      static_cast<v8::PropertyAttribute>(attrs));
+
+  info.GetReturnValue().Set(success);
+}
+
+v8::Local<v8::Object> CallistoAPI::CreateNativeAPI(
+    v8::Isolate* isolate,
+    v8::Local<v8::Context> main_context,
+    blink::WebLocalFrame* frame) {
+  v8::Context::Scope context_scope(main_context);
+
+  v8::Local<v8::Private> frame_key = v8::Private::ForApi(
+      isolate, gin::StringToV8(isolate, kCallistoFrameKey).As<v8::String>());
+  main_context->Global()->SetPrivate(
+      main_context, frame_key, v8::External::New(isolate, frame)).Check();
+
+  v8::Local<v8::Object> callisto = v8::Object::New(isolate);
+
+  auto set_method = [&](v8::Local<v8::Object> obj, const char* name,
+                        v8::FunctionCallback callback) {
+    v8::Local<v8::FunctionTemplate> templ = v8::FunctionTemplate::New(
+        isolate, callback, v8::Local<v8::Value>(),
+        v8::Local<v8::Signature>(), 0, v8::ConstructorBehavior::kThrow);
+    v8::Local<v8::Function> func = templ->GetFunction(main_context).ToLocalChecked();
+    obj->Set(main_context, gin::StringToV8(isolate, name), func).Check();
+  };
+
+  set_method(callisto, "queryObjects", QueryObjects);
+  set_method(callisto, "dumpScopes", DumpScopes);
+  set_method(callisto, "safeApply", SafeApply);
+
+  v8::Local<v8::Object> functions = v8::Object::New(isolate);
+  set_method(functions, "hook", HookFunction);
+  set_method(functions, "restore", RestoreFunction);
+  set_method(functions, "isHooked", IsFunctionHooked);
+  set_method(functions, "clone", CloneFunction);
+  set_method(functions, "dump", Dump);
+  set_method(functions, "build", Build);
+  set_method(functions, "wrapNative", WrapNative);
+  callisto->Set(main_context, gin::StringToV8(isolate, "functions"), functions).Check();
+
+  v8::Local<v8::Object> proxies = v8::Object::New(isolate);
+  set_method(proxies, "patch", PatchProxy);
+  set_method(proxies, "unwrap", UnwrapProxy);
+  set_method(proxies, "isProxy", IsProxy);
+  callisto->Set(main_context, gin::StringToV8(isolate, "proxies"), proxies).Check();
+
+  v8::Local<v8::Object> objects = v8::Object::New(isolate);
+  set_method(objects, "unfreeze", UnfreezeObject);
+  set_method(objects, "unseal", UnsealObject);
+  set_method(objects, "makeExtensible", MakeExtensible);
+  set_method(objects, "overwriteProperty", OverwriteProperty);
+  callisto->Set(main_context, gin::StringToV8(isolate, "objects"), objects).Check();
+
+  v8::Local<v8::Private> api_key = v8::Private::ForApi(
+      isolate, gin::StringToV8(isolate, kCallistoNativeAPIKey).As<v8::String>());
+  main_context->Global()->SetPrivate(main_context, api_key, callisto).Check();
+
+  return callisto;
+}
+
+bool CallistoAPI::CreateForContext(ScriptContext* context) {
+  if (!context) {
+    return false;
+  }
+
+  blink::WebLocalFrame* frame = context->web_frame();
+  if (!frame) {
+    return false;
+  }
+
+  v8::Isolate* isolate = context->isolate();
+  v8::HandleScope handle_scope(isolate);
+  v8::Local<v8::Context> v8_context = context->v8_context();
+  v8::Local<v8::Context> main_context = frame->MainWorldScriptContext();
+
+  if (main_context.IsEmpty()) {
+    return false;
+  }
+
+  v8::Local<v8::Private> frame_key = v8::Private::ForApi(
+      isolate, gin::StringToV8(isolate, kCallistoFrameKey).As<v8::String>());
+
+  {
+    v8::Context::Scope isolated_scope(v8_context);
+    v8_context->Global()->SetPrivate(
+        v8_context, frame_key, v8::External::New(isolate, frame)).Check();
+  }
+
+  v8::Local<v8::Object> native_api = GetNativeAPI(isolate, main_context);
+  if (native_api.IsEmpty()) {
+    native_api = CreateNativeAPI(isolate, main_context, frame);
+  }
+
+  {
+    v8::Context::Scope isolated_scope(v8_context);
+    v8::Local<v8::Object> global = v8_context->Global();
+
+    v8::Maybe<bool> success = global->Set(
+        v8_context, gin::StringToV8(isolate, "Callisto"), native_api);
+
+    if (!success.IsJust() || !success.FromJust()) {
+      return false;
+    }
+
+    global->Set(v8_context, gin::StringToV8(isolate, "C"), native_api).Check();
+  }
+
+  return true;
+}
+
+}  // namespace extensions
--- /dev/null
+++ b/extensions/renderer/callisto_api.h
@@ -0,0 +1,47 @@
+#ifndef EXTENSIONS_RENDERER_CALLISTO_API_H_
+#define EXTENSIONS_RENDERER_CALLISTO_API_H_
+
+#include "v8/include/v8-forward.h"
+
+namespace blink {
+class WebLocalFrame;
+}  // namespace blink
+
+namespace extensions {
+
+class ScriptContext;
+
+class CallistoAPI {
+ public:
+  static bool CreateForContext(ScriptContext* context);
+
+ private:
+  static v8::Local<v8::Object> CreateNativeAPI(v8::Isolate* isolate,
+                                                v8::Local<v8::Context> main_context,
+                                                blink::WebLocalFrame* frame);
+
+  static void QueryObjects(const v8::FunctionCallbackInfo<v8::Value>& info);
+  static void DumpScopes(const v8::FunctionCallbackInfo<v8::Value>& info);
+  static void SafeApply(const v8::FunctionCallbackInfo<v8::Value>& info);
+  static void HookFunction(const v8::FunctionCallbackInfo<v8::Value>& info);
+  static void RestoreFunction(const v8::FunctionCallbackInfo<v8::Value>& info);
+  static void IsFunctionHooked(const v8::FunctionCallbackInfo<v8::Value>& info);
+  static void CloneFunction(const v8::FunctionCallbackInfo<v8::Value>& info);
+  static void Dump(const v8::FunctionCallbackInfo<v8::Value>& info);
+  static void Build(const v8::FunctionCallbackInfo<v8::Value>& info);
+  static void WrapNative(const v8::FunctionCallbackInfo<v8::Value>& info);
+  static void PatchProxy(const v8::FunctionCallbackInfo<v8::Value>& info);
+  static void UnwrapProxy(const v8::FunctionCallbackInfo<v8::Value>& info);
+  static void IsProxy(const v8::FunctionCallbackInfo<v8::Value>& info);
+  static void UnfreezeObject(const v8::FunctionCallbackInfo<v8::Value>& info);
+  static void UnsealObject(const v8::FunctionCallbackInfo<v8::Value>& info);
+  static void MakeExtensible(const v8::FunctionCallbackInfo<v8::Value>& info);
+  static void OverwriteProperty(const v8::FunctionCallbackInfo<v8::Value>& info);
+
+  static blink::WebLocalFrame* GetFrameFromContext(v8::Isolate* isolate,
+                                                   v8::Local<v8::Context> context);
+};
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_RENDERER_CALLISTO_API_H_
--- /dev/null
+++ b/extensions/renderer/main_world_portal.cc
@@ -0,0 +1,402 @@
+// Copyright 2025 The Callisto Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "extensions/renderer/main_world_portal.h"
+
+#include "extensions/renderer/script_context.h"
+#include "gin/converter.h"
+#include "third_party/blink/public/web/web_local_frame.h"
+#include "v8/include/v8-context.h"
+#include "v8/include/v8-exception.h"
+#include "v8/include/v8-external.h"
+#include "v8/include/v8-function.h"
+#include "v8/include/v8-object.h"
+#include "v8/include/v8-primitive.h"
+#include "v8/include/v8-proxy.h"
+#include "v8/include/v8-template.h"
+
+namespace extensions {
+
+namespace {
+
+const char kFramePointerKey[] = "mainWorldPortal_frame";
+
+blink::WebLocalFrame* GetFrameFromHandler(v8::Isolate* isolate,
+                                          v8::Local<v8::Object> handler) {
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+  v8::Local<v8::Private> key =
+      v8::Private::ForApi(isolate, gin::StringToV8(isolate, kFramePointerKey)
+                                       .As<v8::String>());
+  v8::Local<v8::Value> value;
+  if (!handler->GetPrivate(context, key).ToLocal(&value) ||
+      !value->IsExternal()) {
+    return nullptr;
+  }
+  return static_cast<blink::WebLocalFrame*>(value.As<v8::External>()->Value());
+}
+
+}  // namespace
+
+v8::MaybeLocal<v8::Object> MainWorldPortal::GetMainWorldGlobal(
+    v8::Isolate* isolate,
+    blink::WebLocalFrame* frame) {
+  if (!frame) {
+    return v8::MaybeLocal<v8::Object>();
+  }
+
+  v8::Local<v8::Context> main_context = frame->MainWorldScriptContext();
+  if (main_context.IsEmpty()) {
+    return v8::MaybeLocal<v8::Object>();
+  }
+
+  return main_context->Global();
+}
+
+v8::MaybeLocal<v8::Context> MainWorldPortal::GetMainWorldContext(
+    v8::Isolate* isolate,
+    blink::WebLocalFrame* frame) {
+  if (!frame) {
+    return v8::MaybeLocal<v8::Context>();
+  }
+
+  v8::Local<v8::Context> main_context = frame->MainWorldScriptContext();
+  if (main_context.IsEmpty()) {
+    return v8::MaybeLocal<v8::Context>();
+  }
+
+  return main_context;
+}
+
+void MainWorldPortal::TrapGet(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+
+  if (info.Length() < 3) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Invalid trap arguments")));
+    return;
+  }
+
+  v8::Local<v8::Value> property = info[1];
+
+  v8::Local<v8::Object> handler = info.This().As<v8::Object>();
+  blink::WebLocalFrame* frame = GetFrameFromHandler(isolate, handler);
+  if (!frame) {
+    isolate->ThrowException(v8::Exception::Error(
+        gin::StringToV8(isolate, "Frame no longer available")));
+    return;
+  }
+
+  v8::Local<v8::Context> main_context;
+  if (!GetMainWorldContext(isolate, frame).ToLocal(&main_context)) {
+    isolate->ThrowException(v8::Exception::Error(
+        gin::StringToV8(isolate, "Cannot access main world context")));
+    return;
+  }
+
+  v8::Local<v8::Object> main_global;
+  if (!GetMainWorldGlobal(isolate, frame).ToLocal(&main_global)) {
+    isolate->ThrowException(v8::Exception::Error(
+        gin::StringToV8(isolate, "Cannot access main world global")));
+    return;
+  }
+
+  v8::Context::Scope context_scope(main_context);
+
+  v8::Local<v8::Value> result;
+  v8::TryCatch try_catch(isolate);
+
+  if (!main_global->Get(main_context, property).ToLocal(&result)) {
+    if (try_catch.HasCaught()) {
+      try_catch.ReThrow();
+    }
+    return;
+  }
+
+  info.GetReturnValue().Set(result);
+}
+
+void MainWorldPortal::TrapSet(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+
+  if (info.Length() < 4) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Invalid trap arguments")));
+    return;
+  }
+
+  v8::Local<v8::Value> property = info[1];
+  v8::Local<v8::Value> value = info[2];
+
+  v8::Local<v8::Object> handler = info.This().As<v8::Object>();
+  blink::WebLocalFrame* frame = GetFrameFromHandler(isolate, handler);
+  if (!frame) {
+    isolate->ThrowException(v8::Exception::Error(
+        gin::StringToV8(isolate, "Frame no longer available")));
+    return;
+  }
+
+  v8::Local<v8::Context> main_context;
+  if (!GetMainWorldContext(isolate, frame).ToLocal(&main_context)) {
+    isolate->ThrowException(v8::Exception::Error(
+        gin::StringToV8(isolate, "Cannot access main world context")));
+    return;
+  }
+
+  v8::Local<v8::Object> main_global;
+  if (!GetMainWorldGlobal(isolate, frame).ToLocal(&main_global)) {
+    isolate->ThrowException(v8::Exception::Error(
+        gin::StringToV8(isolate, "Cannot access main world global")));
+    return;
+  }
+
+  v8::Context::Scope context_scope(main_context);
+
+  v8::TryCatch try_catch(isolate);
+  v8::Maybe<bool> result = main_global->Set(main_context, property, value);
+
+  if (result.IsNothing()) {
+    if (try_catch.HasCaught()) {
+      try_catch.ReThrow();
+    }
+    return;
+  }
+
+  info.GetReturnValue().Set(result.FromJust());
+}
+
+void MainWorldPortal::TrapHas(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+
+  if (info.Length() < 2) {
+    isolate->ThrowException(v8::Exception::TypeError(
+        gin::StringToV8(isolate, "Invalid trap arguments")));
+    return;
+  }
+
+  v8::Local<v8::Value> property = info[1];
+
+  v8::Local<v8::Object> handler = info.This().As<v8::Object>();
+  blink::WebLocalFrame* frame = GetFrameFromHandler(isolate, handler);
+  if (!frame) {
+    info.GetReturnValue().Set(false);
+    return;
+  }
+
+  v8::Local<v8::Context> main_context;
+  if (!GetMainWorldContext(isolate, frame).ToLocal(&main_context)) {
+    info.GetReturnValue().Set(false);
+    return;
+  }
+
+  v8::Local<v8::Object> main_global;
+  if (!GetMainWorldGlobal(isolate, frame).ToLocal(&main_global)) {
+    info.GetReturnValue().Set(false);
+    return;
+  }
+
+  v8::Context::Scope context_scope(main_context);
+
+  v8::Maybe<bool> has_prop = main_global->Has(main_context, property);
+  if (has_prop.IsNothing()) {
+    info.GetReturnValue().Set(false);
+    return;
+  }
+
+  info.GetReturnValue().Set(has_prop.FromJust());
+}
+
+void MainWorldPortal::TrapOwnKeys(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+
+  v8::Local<v8::Object> handler = info.This().As<v8::Object>();
+  blink::WebLocalFrame* frame = GetFrameFromHandler(isolate, handler);
+  if (!frame) {
+    info.GetReturnValue().Set(v8::Array::New(isolate));
+    return;
+  }
+
+  v8::Local<v8::Context> main_context;
+  if (!GetMainWorldContext(isolate, frame).ToLocal(&main_context)) {
+    info.GetReturnValue().Set(v8::Array::New(isolate));
+    return;
+  }
+
+  v8::Local<v8::Object> main_global;
+  if (!GetMainWorldGlobal(isolate, frame).ToLocal(&main_global)) {
+    info.GetReturnValue().Set(v8::Array::New(isolate));
+    return;
+  }
+
+  v8::Context::Scope context_scope(main_context);
+
+  v8::Local<v8::Array> keys;
+  if (!main_global->GetOwnPropertyNames(main_context).ToLocal(&keys)) {
+    info.GetReturnValue().Set(v8::Array::New(isolate));
+    return;
+  }
+
+  info.GetReturnValue().Set(keys);
+}
+
+void MainWorldPortal::TrapGetOwnPropertyDescriptor(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+
+  if (info.Length() < 2) {
+    info.GetReturnValue().Set(v8::Undefined(isolate));
+    return;
+  }
+
+  v8::Local<v8::Value> property = info[1];
+
+  v8::Local<v8::Object> handler = info.This().As<v8::Object>();
+  blink::WebLocalFrame* frame = GetFrameFromHandler(isolate, handler);
+  if (!frame) {
+    info.GetReturnValue().Set(v8::Undefined(isolate));
+    return;
+  }
+
+  v8::Local<v8::Context> main_context;
+  if (!GetMainWorldContext(isolate, frame).ToLocal(&main_context)) {
+    info.GetReturnValue().Set(v8::Undefined(isolate));
+    return;
+  }
+
+  v8::Local<v8::Object> main_global;
+  if (!GetMainWorldGlobal(isolate, frame).ToLocal(&main_global)) {
+    info.GetReturnValue().Set(v8::Undefined(isolate));
+    return;
+  }
+
+  v8::Context::Scope context_scope(main_context);
+
+  v8::Local<v8::Value> descriptor;
+  if (!property->IsName()) {
+    info.GetReturnValue().Set(v8::Undefined(isolate));
+    return;
+  }
+
+  if (!main_global->GetOwnPropertyDescriptor(main_context, property.As<v8::Name>())
+           .ToLocal(&descriptor)) {
+    info.GetReturnValue().Set(v8::Undefined(isolate));
+    return;
+  }
+
+  info.GetReturnValue().Set(descriptor);
+}
+
+void MainWorldPortal::TrapDeleteProperty(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+
+  if (info.Length() < 2) {
+    info.GetReturnValue().Set(false);
+    return;
+  }
+
+  v8::Local<v8::Value> property = info[1];
+
+  v8::Local<v8::Object> handler = info.This().As<v8::Object>();
+  blink::WebLocalFrame* frame = GetFrameFromHandler(isolate, handler);
+  if (!frame) {
+    info.GetReturnValue().Set(false);
+    return;
+  }
+
+  v8::Local<v8::Context> main_context;
+  if (!GetMainWorldContext(isolate, frame).ToLocal(&main_context)) {
+    info.GetReturnValue().Set(false);
+    return;
+  }
+
+  v8::Local<v8::Object> main_global;
+  if (!GetMainWorldGlobal(isolate, frame).ToLocal(&main_global)) {
+    info.GetReturnValue().Set(false);
+    return;
+  }
+
+  v8::Context::Scope context_scope(main_context);
+
+  v8::Maybe<bool> result = main_global->Delete(main_context, property);
+  if (result.IsNothing()) {
+    info.GetReturnValue().Set(false);
+    return;
+  }
+
+  info.GetReturnValue().Set(result.FromJust());
+}
+
+v8::Local<v8::Object> MainWorldPortal::CreateProxyHandler(
+    v8::Isolate* isolate,
+    v8::Local<v8::Context> context) {
+  v8::EscapableHandleScope handle_scope(isolate);
+
+  v8::Local<v8::Object> handler = v8::Object::New(isolate);
+
+  auto set_trap = [&](const char* name, v8::FunctionCallback callback) {
+    v8::Local<v8::Function> func =
+        v8::Function::New(context, callback).ToLocalChecked();
+    handler->Set(context, gin::StringToV8(isolate, name), func).Check();
+  };
+
+  set_trap("get", TrapGet);
+  set_trap("set", TrapSet);
+  set_trap("has", TrapHas);
+  set_trap("ownKeys", TrapOwnKeys);
+  set_trap("getOwnPropertyDescriptor", TrapGetOwnPropertyDescriptor);
+  set_trap("deleteProperty", TrapDeleteProperty);
+
+  return handle_scope.Escape(handler);
+}
+
+bool MainWorldPortal::CreateForContext(ScriptContext* context) {
+  if (!context) {
+    return false;
+  }
+
+  blink::WebLocalFrame* frame = context->web_frame();
+  if (!frame) {
+    return false;
+  }
+
+  v8::Isolate* isolate = context->isolate();
+  v8::HandleScope handle_scope(isolate);
+  v8::Local<v8::Context> v8_context = context->v8_context();
+  v8::Context::Scope context_scope(v8_context);
+
+  v8::Local<v8::Context> main_context = frame->MainWorldScriptContext();
+  if (main_context.IsEmpty()) {
+    return false;
+  }
+
+  v8::Local<v8::Object> handler = CreateProxyHandler(isolate, v8_context);
+
+  v8::Local<v8::Private> frame_key =
+      v8::Private::ForApi(isolate, gin::StringToV8(isolate, kFramePointerKey)
+                                       .As<v8::String>());
+  handler->SetPrivate(v8_context, frame_key, v8::External::New(isolate, frame))
+      .Check();
+
+  v8::Local<v8::Object> target = v8::Object::New(isolate);
+
+  v8::Local<v8::Proxy> proxy;
+  if (!v8::Proxy::New(v8_context, target, handler).ToLocal(&proxy)) {
+    return false;
+  }
+
+  v8::Local<v8::Object> global = v8_context->Global();
+  v8::Maybe<bool> success = global->Set(
+      v8_context, gin::StringToV8(isolate, "mainWorld"), proxy);
+
+  return success.IsJust() && success.FromJust();
+}
+
+}  // namespace extensions
--- /dev/null
+++ b/extensions/renderer/main_world_portal.h
@@ -0,0 +1,46 @@
+// Copyright 2025 The Callisto Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_RENDERER_MAIN_WORLD_PORTAL_H_
+#define EXTENSIONS_RENDERER_MAIN_WORLD_PORTAL_H_
+
+#include "v8/include/v8-forward.h"
+
+namespace blink {
+class WebLocalFrame;
+}
+
+namespace extensions {
+
+class ScriptContext;
+
+class MainWorldPortal {
+ public:
+  static bool CreateForContext(ScriptContext* context);
+
+ private:
+  static void TrapGet(const v8::FunctionCallbackInfo<v8::Value>& info);
+  static void TrapSet(const v8::FunctionCallbackInfo<v8::Value>& info);
+  static void TrapHas(const v8::FunctionCallbackInfo<v8::Value>& info);
+  static void TrapOwnKeys(const v8::FunctionCallbackInfo<v8::Value>& info);
+  static void TrapGetOwnPropertyDescriptor(
+      const v8::FunctionCallbackInfo<v8::Value>& info);
+  static void TrapDeleteProperty(
+      const v8::FunctionCallbackInfo<v8::Value>& info);
+
+  static v8::MaybeLocal<v8::Object> GetMainWorldGlobal(
+      v8::Isolate* isolate,
+      blink::WebLocalFrame* frame);
+
+  static v8::MaybeLocal<v8::Context> GetMainWorldContext(
+      v8::Isolate* isolate,
+      blink::WebLocalFrame* frame);
+
+  static v8::Local<v8::Object> CreateProxyHandler(v8::Isolate* isolate,
+                                                   v8::Local<v8::Context> context);
+};
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_RENDERER_MAIN_WORLD_PORTAL_H_
--- a/extensions/renderer/native_extension_bindings_system.cc
+++ b/extensions/renderer/native_extension_bindings_system.cc
@@ -42,11 +42,13 @@
 #include "extensions/renderer/bindings/api_binding_js_util.h"
 #include "extensions/renderer/bindings/api_binding_util.h"
 #include "extensions/renderer/console.h"
+#include "extensions/renderer/callisto_api.h"
 #include "extensions/renderer/extension_frame_helper.h"
 #include "extensions/renderer/extension_interaction_provider.h"
 #include "extensions/renderer/extension_js_runner.h"
 #include "extensions/renderer/get_script_context.h"
 #include "extensions/renderer/ipc_message_sender.h"
+#include "extensions/renderer/main_world_portal.h"
 #include "extensions/renderer/module_system.h"
 #include "extensions/renderer/renderer_extension_registry.h"
 #include "extensions/renderer/renderer_frame_context_data.h"
@@ -515,6 +517,8 @@ void NativeExtensionBindingsSystem::DidC
   // since main world script contexts have a different mojom::ContextType type.
   if (context->context_type() == mojom::ContextType::kContentScript) {
     SetScriptingParams(context);
+    MainWorldPortal::CreateForContext(context);
+    CallistoAPI::CreateForContext(context);
   }
 }
 
